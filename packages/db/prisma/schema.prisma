generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// NextAuth.js 필수 모델
model Account {
  id                       String  @id @default(cuid())
  userId                   String
  type                     String
  provider                 String
  providerAccountId        String
  refresh_token            String? @db.Text
  access_token             String? @db.Text
  expires_at               Int?
  token_type               String?
  scope                    String?
  id_token                 String? @db.Text
  session_state            String?
  refresh_token_expires_in Int? // 카카오 OAuth용 추가

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                String    @id @default(cuid())
  name              String?
  email             String?   @unique
  emailVerified     DateTime?
  image             String?
  password          String? // 이메일 로그인용 (OAuth 유저는 null)
  // 카카오톡 알림용 토큰
  kakaoAccessToken  String?   @db.Text
  kakaoRefreshToken String?   @db.Text
  kakaoTokenExpiry  DateTime?

  // RBAC
  planId String?
  plan   Plan?   @relation(fields: [planId], references: [id], onDelete: SetNull)
  roles  Role[]

  // 관계
  accounts           Account[]
  sessions           Session[]
  accommodations     Accommodation[]
  checkLogs          CheckLog[]
  settingsChangeLogs SettingsChangeLog[]
  auditLogs          AuditLog[]          @relation("AuditLogActor")
  auditLogsAsTarget  AuditLog[]          @relation("AuditLogTarget")
  subscriptions      Subscription[]

  // Selector 관리
  createdSelectors   PlatformSelector[]  @relation("SelectorCreatedBy")
  updatedSelectors   PlatformSelector[]  @relation("SelectorUpdatedBy")
  createdPatterns    PlatformPattern[]   @relation("PatternCreatedBy")
  selectorChangeLogs SelectorChangeLog[] @relation("SelectorChangeLogBy")
  caseMessages       CaseMessage[]

  // 튜토리얼
  tutorialCompletedAt DateTime?
  tutorialDismissedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// 숙소 모델
model Accommodation {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name     String // 숙소 이름 (사용자 지정)
  platform Platform // airbnb, agoda
  url      String // 숙소 URL
  checkIn  DateTime // 체크인 날짜
  checkOut DateTime // 체크아웃 날짜
  adults   Int      @default(2) // 인원 수
  rooms    Int      @default(1) // 객실 수

  isActive          Boolean            @default(true) // 모니터링 활성화 여부
  lastCheck         DateTime? // 마지막 체크 시간
  lastStatus        AvailabilityStatus @default(UNKNOWN) // 마지막 상태
  lastPrice         String? // 마지막 확인된 가격 (raw 문자열)
  lastPriceAmount   Int? // 파싱된 숫자 (최소 단위: 원/센트)
  lastPriceCurrency String? // 통화 코드 (KRW, USD, EUR, GBP, CHF)

  // === JSON-LD 메타데이터 (플랫폼에서 추출) ===
  platformId          String? // 플랫폼별 고유 ID (Airbnb room ID, Agoda hotel slug)
  platformName        String? // 플랫폼에서 가져온 숙소명
  platformImage       String? // 대표 이미지 URL
  platformDescription String? @db.Text // 숙소 설명 (긴 텍스트)

  // 주소 정보
  addressCountry  String? // 국가
  addressRegion   String? // 지역 (도/주)
  addressLocality String? // 세부 지역 (구/시)
  postalCode      String? // 우편번호
  streetAddress   String? // 상세 주소

  // 평점 정보
  ratingValue Float? // 평점 (1-10)
  reviewCount Int? // 리뷰 수

  // 위치 좌표
  latitude  Float? // 위도
  longitude Float? // 경도

  // 기타 메타데이터 (전체 JSON-LD 또는 추가 정보)
  platformMetadata Json? // 전체 JSON-LD 데이터

  checkLogs CheckLog[]
  cases     Case[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([isActive])
}

// 모니터링 사이클
model CheckCycle {
  id                  String    @id @default(cuid())
  startedAt           DateTime
  completedAt         DateTime?
  durationMs          Int?
  totalCount          Int       @default(0)
  successCount        Int       @default(0)
  errorCount          Int       @default(0)
  concurrency         Int
  browserPoolSize     Int
  navigationTimeoutMs Int
  contentWaitMs       Int
  maxRetries          Int
  createdAt           DateTime  @default(now())

  checkLogs CheckLog[]

  @@index([startedAt])
  @@index([concurrency, browserPoolSize])
}

// 체크 로그
model CheckLog {
  id              String        @id @default(cuid())
  accommodationId String
  accommodation   Accommodation @relation(fields: [accommodationId], references: [id], onDelete: Cascade)
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  status           AvailabilityStatus
  price            String? // raw 문자열 (예: "₩150,000")
  priceAmount      Int? // 파싱된 숫자 (최소 단위: 원/센트)
  priceCurrency    String? // 통화 코드 (KRW, USD, EUR, GBP, CHF)
  errorMessage     String?
  notificationSent Boolean            @default(false)

  // 체크 시점의 예약 일정 (일정 변경 시 가격 추이 구분용)
  checkIn       DateTime?
  checkOut      DateTime?
  pricePerNight Int? // 1박당 가격 (priceAmount / 숙박일수)

  cycleId        String?
  cycle          CheckCycle?         @relation(fields: [cycleId], references: [id], onDelete: SetNull)
  durationMs     Int?
  retryCount     Int                 @default(0)
  previousStatus AvailabilityStatus?

  conditionMetEvents ConditionMetEvent[]

  createdAt DateTime @default(now())

  @@index([accommodationId])
  @@index([createdAt])
  @@index([cycleId])
  @@index([accommodationId, checkIn, checkOut])
}

model WorkerHeartbeat {
  id                    String             @id @default("singleton")
  startedAt             DateTime           @default(now())
  lastHeartbeatAt       DateTime           @default(now())
  isProcessing          Boolean            @default(false)
  schedule              String             @default("*/30 * * * *")
  accommodationsChecked Int                @default(0)
  lastCycleErrors       Int                @default(0)
  lastCycleDurationMs   Int?
  updatedAt             DateTime           @updatedAt
  history               HeartbeatHistory[]
}

model HeartbeatHistory {
  id           Int             @id @default(autoincrement())
  timestamp    DateTime        @default(now())
  status       String // 'healthy', 'unhealthy', 'processing'
  isProcessing Boolean         @default(false)
  uptime       Float? // 실행 시간 (초)
  workerId     String          @default("singleton")
  worker       WorkerHeartbeat @relation(fields: [workerId], references: [id], onDelete: Cascade)

  @@index([timestamp])
  @@index([workerId])
}

enum Platform {
  AIRBNB
  AGODA
}

enum AvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
  ERROR
  UNKNOWN
}

// 설정 변경 감사 로그
model SettingsChangeLog {
  id          String   @id @default(cuid())
  settingKey  String
  oldValue    String
  newValue    String
  changedById String
  changedBy   User     @relation(fields: [changedById], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@index([settingKey])
  @@index([createdAt])
}

// 운영 설정 (KV 방식)
model SystemSettings {
  key         String   @id // 설정 키 (예: "worker.cronSchedule")
  value       String // 문자열로 저장
  type        String   @default("string") // string | int | boolean
  category    String // worker | browser | checker | monitoring | notification | seo
  description String? // 관리자 UI 표시용 설명
  minValue    String? // 최솟값 (int 타입 설정용)
  maxValue    String? // 최댓값 (int 타입 설정용)
  updatedAt   DateTime @updatedAt

  @@index([category])
}

// ── RBAC ──

enum QuotaKey {
  MAX_ACCOMMODATIONS
  CHECK_INTERVAL_MIN
}

model Plan {
  id            String         @id @default(cuid())
  name          String         @unique // "FREE", "PRO", "BIZ"
  description   String?
  price         Int            @default(0)
  interval      String         @default("month")
  roles         Role[]
  quotas        PlanQuota[]
  users         User[]
  subscriptions Subscription[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
}

model PlanQuota {
  id     String   @id @default(cuid())
  planId String
  plan   Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)
  key    QuotaKey
  value  Int

  @@unique([planId, key])
}

model Role {
  id          String       @id @default(cuid())
  name        String       @unique // "USER", "ADMIN"
  description String?
  permissions Permission[]
  users       User[]
  plans       Plan[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Permission {
  id          String   @id @default(cuid())
  action      String   @unique // "admin:access", "accommodation:create"
  description String?
  roles       Role[]
  createdAt   DateTime @default(now())
}

model AuditLog {
  id         String   @id @default(cuid())
  actorId    String?
  actor      User?    @relation("AuditLogActor", fields: [actorId], references: [id], onDelete: SetNull)
  targetId   String
  targetUser User?    @relation("AuditLogTarget", fields: [targetId], references: [id], onDelete: Cascade)
  entityType String // "User", "Role", "Plan"
  action     String // "role.assign", "plan.change"
  oldValue   Json?
  newValue   Json?
  ipAddress  String?
  createdAt  DateTime @default(now())

  @@index([actorId])
  @@index([targetId])
  @@index([createdAt])
}

// ── Subscription (결제 이력) ──

enum SubscriptionStatus {
  ACTIVE
  TRIALING
  PAST_DUE
  CANCELED
  EXPIRED
}

model Subscription {
  id                     String             @id @default(cuid())
  userId                 String
  user                   User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  planId                 String
  plan                   Plan               @relation(fields: [planId], references: [id], onDelete: Restrict)
  status                 SubscriptionStatus @default(ACTIVE)
  currentPeriodStart     DateTime
  currentPeriodEnd       DateTime
  canceledAt             DateTime?
  cancelReason           String?
  paymentProvider        String? // "stripe", "toss", etc.
  externalSubscriptionId String? // 외부 결제 시스템 ID
  createdAt              DateTime           @default(now())
  updatedAt              DateTime           @updatedAt

  @@index([userId])
  @@index([status])
  @@index([currentPeriodEnd])
}

// ── Dynamic Selector Management ──

enum SelectorCategory {
  PRICE // 가격 추출
  AVAILABILITY // 예약 가능 여부
  METADATA // JSON-LD 메타데이터
  PLATFORM_ID // 플랫폼 고유 ID
}

enum PatternType {
  AVAILABLE
  UNAVAILABLE
}

model PlatformSelector {
  id            String           @id @default(cuid())
  platform      Platform
  category      SelectorCategory
  name          String // "Total Price Aria Label"
  selector      String // "[aria-label*=\"총액\"]"
  extractorCode String?          @db.Text // 복잡한 추출 로직 (JavaScript 코드)
  priority      Int              @default(0)
  isActive      Boolean          @default(true)
  description   String?

  createdById String?
  createdBy   User?   @relation("SelectorCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)
  updatedById String?
  updatedBy   User?   @relation("SelectorUpdatedBy", fields: [updatedById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([platform, category, name])
  @@index([platform, category, isActive])
  @@index([platform, isActive, priority])
}

model PlatformPattern {
  id          String      @id @default(cuid())
  platform    Platform
  patternType PatternType
  pattern     String // "예약하기"
  locale      String      @default("ko")
  isActive    Boolean     @default(true)
  priority    Int         @default(0)

  createdById String?
  createdBy   User?   @relation("PatternCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([platform, patternType, pattern])
  @@index([platform, patternType, isActive])
}

model SelectorChangeLog {
  id          String   @id @default(cuid())
  entityType  String // "PlatformSelector" | "PlatformPattern"
  entityId    String
  action      String // "create" | "update" | "delete" | "toggle"
  field       String? // 변경된 필드 (update 시)
  oldValue    String?  @db.Text
  newValue    String?  @db.Text
  changedById String
  changedBy   User     @relation("SelectorChangeLogBy", fields: [changedById], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())

  @@index([entityType, entityId])
  @@index([changedById])
  @@index([createdAt])
}

// ── Google Form Intake ──

enum FormQuestionField {
  CONTACT_CHANNEL
  CONTACT_VALUE
  TARGET_URL
  CONDITION_DEFINITION
  REQUEST_WINDOW
  CHECK_FREQUENCY
  BILLING_CONSENT
  SCOPE_CONSENT
}

enum FormSubmissionStatus {
  RECEIVED
  NEEDS_REVIEW
  REJECTED
  PROCESSED
}

model FormSubmission {
  id                           String               @id @default(cuid())
  responseId                   String               @unique
  status                       FormSubmissionStatus @default(RECEIVED)
  rawPayload                   Json
  formVersion                  String?
  sourceIp                     String?
  extractedFields              Json?
  rejectionReason              String?
  consentBillingOnConditionMet Boolean?
  consentServiceScope          Boolean?
  consentCapturedAt            DateTime?
  consentTexts                 Json?
  receivedAt                   DateTime             @default(now())
  createdAt                    DateTime             @default(now())
  updatedAt                    DateTime             @updatedAt

  case Case?

  @@index([status])
  @@index([receivedAt])
}

model FormQuestionMapping {
  id             String            @id @default(cuid())
  formKey        String            @default("*")
  field          FormQuestionField
  questionItemId String?
  questionTitle  String
  expectedAnswer String?
  isActive       Boolean           @default(true)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@unique([formKey, field])
  @@index([formKey, isActive])
  @@index([isActive])
}

// ── Case Pipeline (운영 상태 머신) ──

enum CaseStatus {
  RECEIVED
  REVIEWING
  NEEDS_CLARIFICATION
  WAITING_PAYMENT
  ACTIVE_MONITORING
  CONDITION_MET
  BILLED
  CLOSED
  REJECTED
  EXPIRED
  CANCELLED
}

model Case {
  id                      String         @id @default(cuid())
  submissionId            String         @unique
  submission              FormSubmission @relation(fields: [submissionId], references: [id])
  status                  CaseStatus     @default(RECEIVED)
  assignedTo              String?
  statusChangedAt         DateTime       @default(now())
  statusChangedBy         String?
  note                    String?        @db.Text
  ambiguityResult         Json?
  clarificationResolvedAt DateTime?
  paymentConfirmedAt      DateTime?
  paymentConfirmedBy      String?
  accommodationId         String?
  accommodation           Accommodation? @relation(fields: [accommodationId], references: [id], onDelete: SetNull)
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt

  statusLogs         CaseStatusLog[]
  conditionMetEvents ConditionMetEvent[]
  notifications      CaseNotification[]
  billingEvent       BillingEvent?
  messages           CaseMessage[]
  priceQuotes        PriceQuote[]

  @@index([status])
  @@index([createdAt])
}

model PriceQuote {
  id                   String   @id @default(cuid())
  caseId               String
  case                 Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  pricingPolicyVersion String
  inputsSnapshot       Json
  weightsSnapshot      Json
  computedAmountKrw    Int
  roundedAmountKrw     Int
  changeReason         String   @db.Text
  isActive             Boolean  @default(true)
  createdBy            String
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  /// DB-level invariant: one active quote per case is enforced via partial unique
  /// index "PriceQuote_caseId_active_unique_idx" (migration 20260215113000).
  @@index([caseId])
  @@index([caseId, isActive])
}

model CaseStatusLog {
  id          String     @id @default(cuid())
  caseId      String
  case        Case       @relation(fields: [caseId], references: [id], onDelete: Cascade)
  fromStatus  CaseStatus
  toStatus    CaseStatus
  changedById String
  reason      String?
  createdAt   DateTime   @default(now())

  @@index([caseId])
  @@index([createdAt])
}

model ConditionMetEvent {
  id               String   @id @default(cuid())
  caseId           String
  case             Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  checkLogId       String
  checkLog         CheckLog @relation(fields: [checkLogId], references: [id], onDelete: Cascade)
  evidenceSnapshot Json
  screenshotBase64 String?  @db.Text
  capturedAt       DateTime
  createdAt        DateTime @default(now())

  billingEvent BillingEvent?

  @@unique([caseId, checkLogId])
  @@index([caseId])
}

// ── Billing & Notification ──

enum NotificationStatus {
  PENDING
  SENT
  FAILED
}

enum BillingEventType {
  CONDITION_MET_FEE
}

model CaseNotification {
  id             String             @id @default(cuid())
  caseId         String
  case           Case               @relation(fields: [caseId], references: [id], onDelete: Cascade)
  channel        String             @default("KAKAO")
  status         NotificationStatus @default(PENDING)
  payload        Json
  sentAt         DateTime?
  failReason     String?            @db.Text
  retryCount     Int                @default(0)
  maxRetries     Int                @default(3)
  idempotencyKey String             @unique
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  @@index([caseId])
  @@index([status])
}

model BillingEvent {
  id                  String            @id @default(cuid())
  caseId              String            @unique
  case                Case              @relation(fields: [caseId], references: [id], onDelete: Cascade)
  type                BillingEventType  @default(CONDITION_MET_FEE)
  conditionMetEventId String            @unique
  conditionMetEvent   ConditionMetEvent @relation(fields: [conditionMetEventId], references: [id])
  amountKrw           Int
  description         String?
  createdAt           DateTime          @default(now())

  @@index([caseId])
}

// ── Landing Click Tracking ──

model LandingEvent {
  id         String   @id @default(cuid())
  eventName  String
  source     String?
  sessionId  String?
  locale     String?
  path       String   @default("/")
  referrer   String?
  userAgent  String?
  ipAddress  String?
  occurredAt DateTime @default(now())
  createdAt  DateTime @default(now())

  @@index([occurredAt])
  @@index([eventName, occurredAt])
  @@index([sessionId])
}

// ── Operator Messages ──

model CaseMessage {
  id          String   @id @default(cuid())
  caseId      String
  case        Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  templateKey String
  channel     String
  content     String   @db.Text
  sentById    String
  sentBy      User     @relation(fields: [sentById], references: [id], onDelete: Restrict, onUpdate: Cascade)
  createdAt   DateTime @default(now())

  @@index([caseId])
  @@index([sentById])
  @@index([createdAt])
}

// ── Public SEO Snapshot ──

model PublicProperty {
  id                 String   @id @default(cuid())
  platform           Platform
  platformPropertyKey String
  slug               String
  name               String
  sourceUrl          String
  imageUrl           String?
  description        String?  @db.Text
  countryKey         String?
  cityKey            String?
  addressRegion      String?
  addressLocality    String?
  ratingValue        Float?
  reviewCount        Int?
  latitude           Float?
  longitude          Float?
  lastObservedAt     DateTime?
  isActive           Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  snapshots   PublicAvailabilitySnapshot[]
  predictions PublicAvailabilityPrediction[]

  @@unique([platform, platformPropertyKey])
  @@unique([platform, slug])
  @@index([countryKey, cityKey])
  @@index([isActive])
}

model PublicAvailabilitySnapshot {
  id               String         @id @default(cuid())
  publicPropertyId String
  publicProperty   PublicProperty @relation(fields: [publicPropertyId], references: [id], onDelete: Cascade)
  snapshotDate     DateTime
  windowStartAt    DateTime
  windowEndAt      DateTime
  sampleSize       Int
  availableCount   Int
  unavailableCount Int
  errorCount       Int
  avgPriceAmount   Int?
  minPriceAmount   Int?
  maxPriceAmount   Int?
  currency         String?
  openRate         Float?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@unique([publicPropertyId, snapshotDate])
  @@index([snapshotDate])
  @@index([openRate])
}

model PublicAvailabilityPrediction {
  id                    String               @id @default(cuid())
  publicPropertyId      String
  publicProperty        PublicProperty       @relation(fields: [publicPropertyId], references: [id], onDelete: Cascade)
  predictedAt           DateTime             @default(now())
  nextLikelyAvailableAt DateTime?
  confidence            PredictionConfidence
  reasoning             String               @db.Text
  windowDays            Int                  @default(28)
  algorithmVersion      String               @default("v1.0")
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt

  @@unique([publicPropertyId, predictedAt])
  @@index([publicPropertyId, predictedAt])
}

enum PredictionConfidence {
  HIGH
  MEDIUM
  LOW
}
