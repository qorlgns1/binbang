#!/usr/bin/env node
/**
 * i18n typegen 스크립트 (WU-11)
 *
 * 기본 locale(ko)의 메시지 JSON에서 TypeScript 타입을 생성한다.
 *
 * 생성 대상:
 * - namespace별 key union 타입
 * - namespace → key 매핑 인터페이스
 * - 타입 안전 translate 함수 헬퍼
 *
 * 출력: packages/shared/src/generated/i18n/messages.ts (gitignored)
 */
import { existsSync, readdirSync, readFileSync, mkdirSync, writeFileSync } from 'node:fs';
import { join, resolve } from 'node:path';

const ROOT = resolve(import.meta.dirname, '..', '..');
const OUTPUT_DIR = join(ROOT, 'packages/shared/src/generated/i18n');
const OUTPUT_FILE = join(OUTPUT_DIR, 'messages.ts');
const BASE_LOCALE = 'ko';

/** 메시지 소스 정의 */
const MESSAGE_SOURCES = [
	{
		id: 'web',
		label: 'Web',
		dir: join(ROOT, 'apps/web/messages', BASE_LOCALE),
	},
	{
		id: 'worker',
		label: 'Worker',
		dir: join(ROOT, 'packages/worker-shared/messages', BASE_LOCALE),
	},
];

/** JSON 객체를 flat key 목록으로 변환 (dot-separated) */
function flattenKeys(obj, prefix = '') {
	const keys = [];
	for (const [key, value] of Object.entries(obj)) {
		const fullKey = prefix ? `${prefix}.${key}` : key;
		if (value && typeof value === 'object' && !Array.isArray(value)) {
			keys.push(...flattenKeys(value, fullKey));
		} else {
			keys.push(fullKey);
		}
	}
	return keys.sort();
}

/** PascalCase 변환 */
function toPascalCase(str) {
	return str.replace(/(^|[-_])(\w)/g, (_, _sep, c) => c.toUpperCase());
}

// ── Main ──

const lines = [
	'// Auto-generated by scripts/i18n/typegen.mjs — DO NOT EDIT',
	`// Base locale: ${BASE_LOCALE}`,
	`// Generated at: ${new Date().toISOString()}`,
	'',
];

for (const source of MESSAGE_SOURCES) {
	if (!existsSync(source.dir)) {
		console.log(`SKIP ${source.id}: directory not found (${source.dir})`);
		continue;
	}
	const namespaces = readdirSync(source.dir)
		.filter((f) => f.endsWith('.json'))
		.map((f) => f.replace('.json', ''))
		.sort();

	if (namespaces.length === 0) {
		console.log(`SKIP ${source.id}: no JSON files found`);
		continue;
	}

	const prefix = toPascalCase(source.id);

	lines.push(`// === ${source.label} Messages ===`);
	lines.push('');

	const nsKeyTypeNames = [];

	for (const ns of namespaces) {
		const filePath = join(source.dir, `${ns}.json`);
		const raw = readFileSync(filePath, 'utf-8');
		const data = JSON.parse(raw);
		const keys = flattenKeys(data);

		const typeName = `${prefix}${toPascalCase(ns)}Key`;
		nsKeyTypeNames.push({ ns, typeName });

		if (keys.length === 0) {
			lines.push(`export type ${typeName} = never;`);
		} else {
			const keyUnion = keys.map((k) => `'${k}'`).join(' | ');
			lines.push(`export type ${typeName} = ${keyUnion};`);
		}
		lines.push('');
	}

	// namespace → key 매핑 인터페이스
	const interfaceName = `${prefix}Messages`;
	lines.push(`export interface ${interfaceName} {`);
	for (const { ns, typeName } of nsKeyTypeNames) {
		lines.push(`\treadonly ${ns}: ${typeName};`);
	}
	lines.push('}');
	lines.push('');

	// namespace union 타입
	lines.push(`export type ${prefix}Namespace = keyof ${interfaceName};`);
	lines.push('');
}

// 타입 안전 translate 헬퍼
lines.push('// === Type-safe translate helpers ===');
lines.push('');
lines.push(
	'/** Type-safe translate function that restricts keys to valid message keys */',
);
lines.push('export type TypedTranslateFunction<Keys extends string> = (');
lines.push('\tkey: Keys,');
lines.push('\tparams?: Record<string, string | number>,');
lines.push(') => string;');
lines.push('');

const content = `${lines.join('\n')}\n`;

// 출력 디렉터리 생성 + 파일 쓰기
mkdirSync(OUTPUT_DIR, { recursive: true });
writeFileSync(OUTPUT_FILE, content, 'utf-8');

console.log(`✓ Generated ${OUTPUT_FILE}`);
